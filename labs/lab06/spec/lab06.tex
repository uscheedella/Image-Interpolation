
\documentclass[letter]{article}
\include{rhewett_style}
\usepackage[margin=1in]{geometry}

\graphicspath{{./figures/}}

\usepackage{ulem} % Make \emph use underline and not italics

\renewcommand{\familydefault}{\sfdefault}

\newcommand{\coursenumber}{CMDA 3634}
\newcommand{\coursecrn}{Hewett}

\newcommand{\assignmenttype}{Lab}
\newcommand{\assignmentnumber}{06}

\newcommand{\assignmentreleasedate}{2019-02-26 10:00:00}
\newcommand{\assignmentduedate}{2019-02-28 23:59:00}

\newcommand{\assignmenttitle}{Approximating Pi with OpenMP}

\newcommand{\mypath}[1]{\texttt{\path{#1}}}
\newcommand{\cmd}[1]{\begin{quote}\texttt{> #1}\end{quote}}

\title{\coursenumber \coursecrn}
\date{}


\pagestyle{fancy}
\fancyhf{}
\lhead{CMDA 3634 SP2019}
\chead{\assignmenttitle}
\rhead{\assignmenttype~\assignmentnumber}
\renewcommand{\footrulewidth}{0.4pt}% default is 0pt; adds rule for footer
\lfoot{Assigned: \assignmentreleasedate}
\cfoot{\thepage}
\rfoot{Due: \assignmentduedate}



\begin{document}

% \maketitle
\thispagestyle{fancy}% Fix pagestyle to put the header and footer back

\begin{itemize}[leftmargin=*]
    \item[] \textbf{\assignmenttype~\assignmentnumber}: \assignmenttitle
    \item[] \textbf{Assigned: } \assignmentreleasedate
    \item[] \textbf{Due: } \assignmentduedate
    \item[] \textbf{Instructions: }
        \begin{itemize}
            \item Written portions of this assignment are submitted via Canvas.  Unless specified otherwise, the written portion of the assignment is to be completed using LaTeX.  All derivations, images, graphs, and tables are to be included in this document.  Handwritten solutions will receive zero credit.
            \item Code portions of this assignment are submitted via \texttt{code.vt.edu}.  Source code must be in the private repository, to which the CMDA 3634 instructors must have access.
        \end{itemize}
    \item[] \textbf{Deliverables:} For this assignment, you are to submit the following:
        \begin{enumerate}
            \item (Canvas) \texttt{<pid>\_\assignmenttype\_06.pdf}: A PDF file, renderd by \texttt{pdflatex} (the file generated by Overleaf is sufficient) containing the answers to the questions requiring written answers.  Use the template provided in the project repository. 
            \item (\texttt{code.vt.edu}) The source files required to compile and run your solutions to the lab and the tex and image files for your report, in the appropriate directories.
        \end{enumerate}
    \item[] \textbf{Collaboration: } This assignment is to be completed by yourself, however, you make seek assistance from your classmates.  In your submission you must indicate from whom you received assistance.
    \item[] \textbf{Honor Code: } By submitting this assignment, you acknowledge that you have adhered to the Virginia Tech Honor Code and attest to the following:
        \begin{quote}
           I have neither given nor received unauthorized assistance on this assignment.  The work I am presenting is ultimately my own.
        \end{quote}
\end{itemize}

\hrule

\pagebreak

\section*{Resources}

\begin{itemize}

    \item OpenMP:
        \begin{itemize}
            \item General tutorial  \url{https://computing.llnl.gov/tutorials/openMP/}
            \item Timing  \url{https://gcc.gnu.org/onlinedocs/gcc-4.5.0/libgomp/omp_005fget_005fwtime.html}
        \end{itemize}
    \item Monte Carlo Pi: \url{https://academo.org/demos/estimating-pi-monte-carlo/}

\end{itemize}

\section*{Task}
In this exercise you will first implement serial code for approximately computing pi and then add OpenMP compiler directives so that your program will parallelize the calculation and use an arbitrary number of threads to compute pi. Once the code runs on your virtualbox you will transfer it to Cascades via git and test it there using the SLURM batch job queueing system.

Monte Carlo algorithm for computing $\pi$: randomly choose points in a box with unit area, with bottom-left corner at the origin and check each random point to see if it is in the unit circle centered at the origin.  The percentage of points inside this box converges to a number proportional to $\pi$.

\textbf{Serial implementation:} The serial implementation is similar to the serial implementation presented in lecture. 

\textbf{Parallel implementation:}  For the parallel implementation, the \texttt{srand48()}/\texttt{drand48} seed and pseudo-random number generating functions are not thread safe because they maintain a single internal state. They have been replaced with the reentrant versions \texttt{srand48\_r} and \texttt{drand48\_r}.  We recommend you use an omp parallel region, and inside that region each thread initializes the random seed based on its thread number.  In the parallel region, perform a regular for loop (i.e not an \texttt{omp parallel for} loop) and use a reduction clause to sum up all the threadâ€™s hit counts.

\textbf{Warning:} I have indicated where you should be running commands in a terminal with the \texttt{>} character.  This character is \textbf{not} part of the command!

\begin{enumerate}

    \item \textbf{Setup} your coding environment.
        \begin{enumerate}
            \item Pull the lab materials from the upstream repository.
        \end{enumerate}

    \item \textbf{Implement} the following requirements in C.  Be sure to use git to commit your code regularly.  Push early, push often!
        \begin{enumerate}
            \item First look at the \texttt{readme} to understand what files and scripts are available.
            \item Now fill in the missing code in \texttt{pi.c}. Recall that we are throwing random points on the unit square resting on the first quadrant of the graph with its lower left vertext at the origin and seeing if they are within a unit circle of radius 1 centered at the origin. 
            \item Run \texttt{pi.c} to make sure its prediction seems reasonable.
            \item Copy your code from part (a) into the respective parts of \texttt{pi\_omp.c}.
            \item Determine which statement to use before the \texttt{for} loop in \texttt{pi\_omp.c}. (Hint: we need to keep \texttt{n} and \texttt{randBuffer} private and form a reduction on \texttt{Ninside}.)
            \item We have changed \texttt{pi\_omp.c} for you so each thread gets a separate random number generator.  However, if we always set the seed to \texttt{12345}, each thread will receive the same random numbers and our estimate of pi will not improve.  Change the argument to \texttt{srand48\_r} to a number that is different for each thread.  
            \item Now run this code with at least two cores. Confirm that you are still approximating pi and that you see a reasonable speedup.
            \item Now run \texttt{scale.sh} on your laptop. Use \texttt{plotScale.py} or the plotting tool of your choice to plot the scaling.  You can also change the number of threads to N using\\
            \texttt{> export OMP\_NUM\_THREADS=N} 
            \item Push your work to \texttt{code.vt.edu}. \texttt{ssh} into Cascades and clone your code. Submit the bash script as a job using \texttt{sbatch}. Then use \texttt{scp} to copy the results back to your laptop and plot them.  
        \end{enumerate}
            
    \item \textbf{Answer} the questions listed below.  You may use Overleaf, but your tex source must be commited to the \mypath{reports/} directory.

    \item \textbf{Submit} your results.
        \begin{enumerate}
            \item After you have completed this lab (which we'll continue in class on Thursday), upload a PDF of your report to Canvas.
            \item Push your source code and latex files to \texttt{code.vt.edu}.
            \item Examine your assignment repository on \url{code.vt.edu} to be sure that all of your materials have been correctly submitted.
        \end{enumerate}
   
\end{enumerate}

\pagebreak
\section*{Questions}

    Answer the following questions.  No template is provided (you may copy one from a previous week if you like).  Place a copy of your report in the \mypath{reports/} directory.

    \begin{enumerate}
        \item Include a screenshot of the welcome screen that you see when you log into Cascades. 
        \item Notice that the serial and parallel versions compute elapsed time in different ways.  Find a description of the \texttt{clock()} function online and think of something unexpected that it might return in our parallel version.
        \item Explain in your own words why this algorithm works.  How many samples are necessary to approximate $\pi$ to 3 digits? 4 digits? 5 digits?  Create a plot which shows the quality of approximation as a function of the number of samples.
        \item Put your scaling plots for the laptop and Cascades in your pdf. 
        \item Observe that we plateau on the laptop (assuming you have less that 16 cores). Why is this?
        
        \item The scaling for Cascades is approximately linear. Why is this? Can we expect this same scaling for other problems?
        
    \item Why is a \texttt{parallel for} on its own insufficient for completing \texttt{pi\_omp.c}?  List modifiers that we needed to add to the basic command.
        
    \end{enumerate}

\end{document}