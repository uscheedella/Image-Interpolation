
\documentclass[letter]{article}
\include{rhewett_style}
\usepackage[margin=1in]{geometry}

\graphicspath{{./figures/}}

\usepackage{ulem} % Make \emph use underline and not italics

\renewcommand{\familydefault}{\sfdefault}

\newcommand{\coursenumber}{CMDA 3634}
\newcommand{\coursecrn}{Martin}

\newcommand{\assignmenttype}{Lab}
\newcommand{\assignmentnumber}{06}

\newcommand{\assignmentreleasedate}{2019-02-17 22:00:00}
\newcommand{\assignmentduedate}{2019-02-27 23:59:00}

\newcommand{\assignmenttitle}{Approximating Pi with OpenMP}

\title{\coursenumber \coursecrn}
\date{}


\pagestyle{fancy}
\fancyhf{}
\lhead{CMDA 3634 SP2019}
\chead{\assignmenttitle}
\rhead{\assignmenttype~\assignmentnumber}
\renewcommand{\footrulewidth}{0.4pt}% default is 0pt; adds rule for footer
\lfoot{Assigned: \assignmentreleasedate}
\cfoot{\thepage}
\rfoot{Due: \assignmentduedate}



\begin{document}

% \maketitle
\thispagestyle{fancy}% Fix pagestyle to put the header and footer back

\begin{itemize}[leftmargin=*]
    \item[] \textbf{\assignmenttype~\assignmentnumber}: \assignmenttitle
    \item[] \textbf{Assigned: } \assignmentreleasedate
    \item[] \textbf{Due: } \assignmentduedate
    \item[] \textbf{Instructions: }
        \begin{itemize}
            \item Written portions of this assignment are submitted via Canvas.  Unless specified otherwise, the written portion of the assignment is to be completed using LaTeX.  All derivations, images, graphs, and tables are to be included in this document.  Handwritten solutions will receive zero credit.
            \item Code portions of this assignment are submitted via \texttt{code.vt.edu}.  Source code must be in the private repository, to which the CMDA 3634 instructors must have access.
        \end{itemize}
    \item[] \textbf{Deliverables:} For this assignment, you are to submit the following:
        \begin{enumerate}
            \item (Canvas) \texttt{<pid>\_\assignmenttype\_06.pdf}: A PDF file, renderd by \texttt{pdflatex} (the file generated by Overleaf is sufficient) containing the answers to the questions requiring written answers.  Use the template provided in the project repository. 
            \item (\texttt{code.vt.edu}) The source files required to compile and run your solutions to the lab and the tex and image files for your report, in the appropriate directories.
        \end{enumerate}
    % \item[] \textbf{Collaboration: } This assignment is to be completed by yourself.
    \item[] \textbf{Collaboration: } This assignment is to be completed by yourself, however, you make seek assistance from your classmates.  In your submission you must indicate from whom you received assistance.
    % \item[] \textbf{Collaboration: } You may work with one partner on this project.  Each partner must submit their own solution and writeup.  In your submission, you must acknowledge your partner.
    \item[] \textbf{Honor Code: } By submitting this assignment, you acknowledge that you have adhered to the Virginia Tech Honor Code and attest to the following:
        \begin{quote}
           I have neither given nor received unauthorized assistance on this assignment.  The work I am presenting is ultimately my own.
        \end{quote}
\end{itemize}

\hrule

\pagebreak

% \section*{Background}
\section*{Resources}

\begin{itemize}

    \item OpenMP:
        \begin{itemize}
            \item General tutorial  \url{https://computing.llnl.gov/tutorials/openMP/}
            \item Timing  \url{https://gcc.gnu.org/onlinedocs/gcc-4.5.0/libgomp/omp_005fget_005fwtime.html}
        \end{itemize}
    \item Monte Carlo Pi: \url{https://academo.org/demos/estimating-pi-monte-carlo/}

\end{itemize}

% \pagebreak
\section*{Task}
In this exercise you will first implement serial code for approximately computing pi and then add OpenMP compiler directives so that your program will parallelize the calculation and use an arbitrary number of threads to compute pi. Once the code runs on your virtualbox you will transfer it to Cascades via git and test it there using the SLURM batch job queueing system.

Monte Carlo algorithm for computing $\pi$: randomly choose points in a box with unit area, with bottom-left corner at the origin and check each random point to see if it is in the unit circle centered at the origin.  The percentage of points inside this box converges to a number proportional to $\pi$.

\textbf{Serial implementation:} The serial implementation is similar to the serial implementation presented in lecture. 

\textbf{Parallel implementation:}  For the parallel implementation, the \texttt{srand48()}/\texttt{drand48} seed and pseudo-random number generating functions are not thread safe because they maintain a single internal state. They have been replaced with the reentrant versions \texttt{srand48\_r} and \texttt{drand48\_r}.  We recommend you use an omp parallel region, and inside that region each thread initializes the random seed based on its thread number.  In the parallel region, perform a regular for loop (i.e not an \texttt{omp parallel for} loop) and use a reduction clause to sum up all the threadâ€™s hit counts.

\textbf{Warning:} I have indicated where you should be running commands in a terminal with the \texttt{>} character.  This character is \textbf{not} part of the command!

\begin{enumerate}

    \item \textbf{Setup} your coding environment.
        \begin{enumerate}
            \item Pull the lab materials from the upstream repository.
                \begin{quote}
                    \texttt{> git fetch upstream master}\\
                    \texttt{> git merge upstream/master}
                \end{quote}
                Be careful with the forward slash in the second command.
            \item Examine the history to see what new files have been added by the instructors.  
                \begin{quote}
                    \texttt{> git log --name-status}
                \end{quote}
            The name status will show, in the log, which files have been added, modified, and removed in each commit.
            \item For the lab on Wednesday, install Openmp: \texttt{> sudo apt install libomp-dev}
            \item Push your local master branch to the origin repository to add the new changes.
                \begin{quote}
                    \texttt{> git push origin master}
                \end{quote}
        \end{enumerate}

    \item \textbf{Implement} the following requirements in C.  Be sure to use git to commit your code regularly.
        \begin{enumerate}
            \item First look at the README to understand what files and scripts are available.
            \item Now fill in the missing code in \texttt{pi.c}. Recall that we are throwing random points on the unit square resting on the first quadrant of the graph with its lower left vertext at the origin and seeing if they are within a unit circle of radius 1 centered at the origin. 
            \item Run \texttt{pi.c} to make sure its prediction seems reasonable.
            \tem Copy your code from part (a) into the respective parts of \texttt{pi\_omp.c}.
            \item Determine which statement to use before the \texttt{for} loop in \texttt{pi\_omp.c}. (Hint: we need to keep \texttt{n} and \texttt{randBuffer} private and form a reduction on \texttt{Ninside}.)
            \item We have changed \texttt{pi\_omp.c} for you so each thread gets a separate random number generator.  However, if we always set the seed to \texttt{12345}, each thread will receive the same random numbers and our estimate of pi will not improve.  Change the argument to \texttt{srand48\_r} to a number that is different for each thread.  
            \item Now run this code with at least two cores. Confirm that you are still approximating pi and that you see a reasonable speedup.
            \item Now run \texttt{scale.sh} on your laptop. Use \texttt{plotScale.py} or the plotting tool of your choice to plot the scaling. You can also change the number of threads to N using\\
            \texttt{> export OMP\_NUM\_THREADS=N} 
            \item Push your work to \texttt{code.vt.edu}. \texttt{ssh} into cascades and clone your code. Submit the bash script as a job using \texttt{sbatch}. Then use \texttt{scp} to copy the results back to your laptop and plot them.  
        \end{enumerate}
            
    \item \textbf{Answer} the questions listed below.  The following workflow uses Overleaf, but you are welcome to use a local tex installation if you prefer.
        \begin{enumerate}
            \item In Overleaf, create a new empty project, and copy in \texttt{lab06\_report.tex} and \texttt{lab06\_rhewett\_style.tex}.
            \item Answer the questions, and upload data files where necessary.
        \end{enumerate}

    \item \textbf{Submit} your results.
        \begin{enumerate}
            \item After you have completed this lab (which we'll continue in class on Wednesday), upload a PDF of your report to Canvas.
            \item Don't forget to clean up before submission (do not commit your cachegrind.###.out files).
            \item Push your source code and latex files to \texttt{code.vt.edu}.  From anywhere in your local projects repository
                \begin{quote}
                    \texttt{> git push origin master}
                \end{quote}
            \item Examine your assignment repository on \url{code.vt.edu} to be sure that all of your materials have been correctly submitted.
        \end{enumerate}
   
\end{enumerate}

\pagebreak
\section*{Questions}

    Answer the following questions using the latex template provided in the \texttt{lab06/report} directory of the assignment repository.

    \begin{enumerate}
        \item Include a screenshot of the welcome screen that you see when you log into Cascades. 
        \item Notice that the serial and parallel versions compute elapsed time in different ways.  Find a description of the \texttt{clock()} function online and think of something unexpected that it might return in our parallel version.
        \item Explain in your own words why this algorithm works.  How many samples are necessary to approximate $\pi$ to 3 digits? 4 digits? 5 digits?  Create a plot which shows the quality of approximation as a function of the number of samples.
        \item Put your scaling plots for the laptop and Cascades in your pdf. 
        \item Observe that we plateau on the laptop (assuming you have less that 16 cores). Why is this?
        
        \item The scaling for Cascades is approximately linear. Why is this? Can we expect this same scaling for other problems?
        
        \item Why is a \texttt{parallel for} on its own insufficient for completing \texttt{pi\_omp.c}?  List modifiers that we needed to add to the basic command.
        
    \end{enumerate}

\end{document}